"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[835],{7502:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"typr-doc/typr-type-system","title":"typr-type-system","description":"Primitive types","source":"@site/docs/typr-doc/typr-type-system.md","sourceDirName":"typr-doc","slug":"/typr-doc/typr-type-system","permalink":"/typr.github.io/build/docs/typr-doc/typr-type-system","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/typr-doc/typr-type-system.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"TypR for R users","permalink":"/typr.github.io/build/docs/typr-doc/typr-for-r-users"},"next":{"title":"Advanced Typr","permalink":"/typr.github.io/build/docs/typr-doc/advanced-typr"}}');var s=t(4848),i=t(8453);const r={sidebar_position:2},c=void 0,o={},l=[{value:"Primitive types",id:"primitive-types",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Records",id:"records",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Functions",id:"functions",level:2},{value:"Tags",id:"tags",level:2},{value:"Union",id:"union",level:2},{value:"Interfaces (nightly)",id:"interfaces-nightly",level:2}];function d(e){const n={br:"br",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"primitive-types",children:"Primitive types"}),"\n",(0,s.jsx)(n.p,{children:"Even though TypR try to be the closest possible to the type system of R, it also takes its own route for certain things and do the translation of R. For now, not all basic R data types are represented but TypR has its own representation."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Basic types:"})}),"\n",(0,s.jsxs)(n.p,{children:["Each basic type gives a vector of size 1 in R. Boleans are now the two lower-case values ",(0,s.jsx)(n.code,{children:"true"})," and ",(0,s.jsx)(n.code,{children:"false"})," instead of the uppercase one (TRUE, FALSE or T, F)."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"name"}),(0,s.jsx)(n.th,{children:"TypR"}),(0,s.jsx)(n.th,{children:"R"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Integers"}),(0,s.jsx)(n.td,{children:"int"}),(0,s.jsx)(n.td,{children:"integer"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Numerics"}),(0,s.jsx)(n.td,{children:"num"}),(0,s.jsx)(n.td,{children:"numeric"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Characters"}),(0,s.jsx)(n.td,{children:"char"}),(0,s.jsx)(n.td,{children:"bool"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Booleans"}),(0,s.jsx)(n.td,{children:"bool"}),(0,s.jsx)(n.td,{children:"logical"})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let a: int <- 5;\nlet b: num <- 5.0; \nlet c: char <- "5";\nlet d: bool <- true;\n\na\n'})}),"\n",(0,s.jsx)(n.h2,{id:"arrays",children:"Arrays"}),"\n",(0,s.jsx)(n.p,{children:"One can build an array from any types. Array keep the informations about the array size and it's type. As any other types, you don't need mention the type annotation. TypR can infer it for you."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Difference with R"}),"\nLike R, TypR's array can only hold one type but this type can't change through time. It mean, all the member of the array must have the same type."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Exemples"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let a: [3, bool] <- [true, false, true];\nlet b <- [true, false, true];\n\na\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," have both the type ",(0,s.jsx)(n.code,{children:"[3, bool]"})," with and without the type inference."]}),"\n",(0,s.jsx)(n.p,{children:"We can also define multidimensional arrays in that way:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"[[1, 2], [3, 4]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"This code will give you this result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Type checking: \n[2, [2, int]]\n\nExecution: \n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The array type from TypR are recursive by definition. This mean an array ",(0,s.jsx)(n.code,{children:"[I, T]"})," is the combination of an index ",(0,s.jsx)(n.code,{children:"I"})," and a type ",(0,s.jsx)(n.code,{children:"T"}),", so ",(0,s.jsx)(n.code,{children:"T"})," can be any type including an other array type ",(0,s.jsx)(n.code,{children:"[J, T]"})," so we can end with an array ",(0,s.jsx)(n.code,{children:"[I, [J, T]]"}),". Since R doesn't support this feature, TypR is smart enougth to transform it to a classical Array type in R."]}),"\n",(0,s.jsx)(n.p,{children:"You can also add as much layer as you want (but not realy sure if it's that readable). You can create a tensor of dimension 3 (an array of arrays of arrays) in this fashion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"I will let you see the result by yourself. But be sure to respect the dimensionality or else it will not work."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Sequences"})}),"\n",(0,s.jsx)(n.p,{children:"Like R, TypR let you define sequence of elements. For instance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"1:4\n"})}),"\n",(0,s.jsx)(n.p,{children:"Will give you this result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Type checking: \n[4, int]\n\nExecution: \n[1] 1 2 3 4\n"})}),"\n",(0,s.jsx)(n.p,{children:"TypR also add the feature of defining steps:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"0:2:20\n"})}),"\n",(0,s.jsx)(n.p,{children:'Just mean "start from zero by step of two until we reach 20". It will give this result:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Type checking: \n[11, int]\n\nExecution: \n[1]  0  2  4  6  8 10 12 14 16 18 20\n"})}),"\n",(0,s.jsxs)(n.p,{children:["TypR offer capabilities to act on array indexing and build functions that define the shape an array should have. It's a powerful tool let typR infer and check the shape of a multidimensional array like a matrix. For instance, sequences generated are juste converted to the ",(0,s.jsx)(n.code,{children:"seq"})," function in R. TypR has this definition for it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"pub let seq <- fn(a: #I, b: #J, c: #K): [#J-#I/#K+1, int] {\n\t...\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At this stage, you dont need to understand everything. This is just a function that take 3 parameters (#I for the start number, #J for the end number and #K for the step) The resulting index is a calculation (#J-#I/#K+1) that TypR can use to guess the shape of the resulting array. This type of generics are ",(0,s.jsx)(n.code,{children:"index generics"}),", those are like super ints who have the power to be used in arrays' index. It give the power to define the resulting shape of complex operations like transpose or the dot product. A tutorial about this topic will come soon (since it can be a whole chapter by imself)."]}),"\n",(0,s.jsx)(n.h2,{id:"records",children:"Records"}),"\n",(0,s.jsx)(n.p,{children:"A record is a structure that hold different type of data. It's the equivalent of a named list in R. It has also his owns capability like the row polymorphism."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Difference with R"}),(0,s.jsx)(n.br,{}),"\n","TypR records are a subtype of R lists. You can't build a records with unlabeled values like in R. This restriction prevent unsafe and unpredictible operations to occure."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Exemples"}),"\nTo build a simple record representing a person with their name and age, you can just write:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:':{name: "John", age: 19}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Will generate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Type checking: \n{name: char, age: int}\n\nExecution: \n$name\n[1] "John"\n\n$age\n[1] 19\n'})}),"\n",(0,s.jsx)(n.p,{children:'To make a distinction with a scope and avoid long names like "list" or "record" for each object creation, We thought this notation will be easier to work with.'}),"\n",(0,s.jsx)(n.p,{children:"To access a member by it's label, you just have to call it in this fashion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let person <- :{name: "John", age: 19};\n\nperson.name\n'})}),"\n",(0,s.jsx)(n.p,{children:"Here, we accessed the name of the person. Records are mainly there to keep together a set of data in a logical way"}),"\n",(0,s.jsx)(n.h2,{id:"tuples",children:"Tuples"}),"\n",(0,s.jsx)(n.p,{children:"R tuples are a specific case of records. Indeed, they are just records who automaticaly generate numered labels. Here:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:':{"John", 19}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Will generate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'Type checking: \n{char, int}\n\nExecution: \n[[1]]\n[1] "John"\n\n[[2]]\n[1] 19\n'})}),"\n",(0,s.jsx)(n.p,{children:"It's a faster and easier way to generate data on the fly."}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.p,{children:"Since TypR is more oriented toward a functional style, functions are values and have a type by themself. They are then anonymous by default and should be set in variables."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Difference with R"}),"\nThere aren't that much difference with R except function are created with the ",(0,s.jsx)(n.code,{children:"fn"})," keyword instead of the ",(0,s.jsx)(n.code,{children:"function"})," one. Also ",(0,s.jsx)(n.code,{children:"return"})," is not a function anymore but a keyword."]}),"\n",(0,s.jsx)(n.p,{children:"You can define a function with a type annotation but it's better to focus only on the function signature and let TypR infer the rest."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let f <- fn(a: int, b: int): bool {\n\ta == b\n};\n\nf(8, 9) # will give false\n"})}),"\n",(0,s.jsx)(n.p,{children:"TypR functions are the most complex elements of TypR since many action (metaprogramming + type checking) must be done in the calling. But a lot of sugar has been added so everyone can use them seemlessely."}),"\n",(0,s.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,s.jsx)(n.p,{children:"Tags are one of the algebraic data type (no need to know what an algebraic data type is yet) I needed the most but didn't know. I was asking myself wich kind of union type of union I should use (general union or tagged union), but those are the elements that bring at the same type the security and flexibility wanted for this language."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Difference with R"})}),"\n",(0,s.jsx)(n.p,{children:"R don't have such a construct since, Tags, unions and even interface are an abstract concept to put some clarity and restriction to what the code should do. But compared to the others, tags are a kind of values and should exist in real R code. I have not made the implementation of the translation to R yet, but I think I will make"}),"\n",(0,s.jsx)(n.p,{children:"Tags are values that one can use on the fly. Each flag is unique and has its own type. It's useful do define some elements like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let none: .None <- None;\nlet nan: .NaN <- NaN;\nlet na: .NA <- NA;\n\nnone\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the tag is named ",(0,s.jsx)(n.code,{children:"[tag_name]"}),", then it's base type is ",(0,s.jsx)(n.code,{children:":[tag_name]"}),". They are R's factors on stero\xefd and even Rust's enums on stero\xefd. You can use them to define some collections (like the Day of the week, gender, etc.)."]}),"\n",(0,s.jsx)(n.p,{children:"Tags can also handle one type with them:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let results: .Val(num) <- Val(7.3);\nlet person: .Person({name: char, age: int}) <- Person(:{name: "Marc", age: 37});\n\nresults\n'})}),"\n",(0,s.jsx)(n.p,{children:"Okay but what are their power ? Well they can be unified together inside a union type ! But here we will see how useful it is for return type in a if close:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'if (true) {\n\t7\n} else {\n\t"seven"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, TypR wont accept this code since ",(0,s.jsx)(n.code,{children:"7"})," (",(0,s.jsx)(n.code,{children:"int"}),") and ",(0,s.jsx)(n.code,{children:'"seven"'})," (",(0,s.jsx)(n.code,{children:"char"}),") aren't the same type. But if we use tags:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'if (true) {\n\tValue(7)\n} else {\n\tString("seven")\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The return type will be ",(0,s.jsx)(n.code,{children:".Value(int) | .String(char)"}),' meaning TypR will automaticaly unify the results if they are tags. Tags must be "unwrapped" to access the values within, forcing a user to handle the different cases.']}),"\n",(0,s.jsx)(n.h2,{id:"union",children:"Union"}),"\n",(0,s.jsx)(n.p,{children:"Union are an abstract concept that won't really appear in the resulting R code. In summary, you can unify any kind of type. You can now regroup tags to create other type. For instance, to create an option type, one can create an alias into this union of values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let a: int | bool <- FALSE;\n\na\n"})}),"\n",(0,s.jsx)(n.p,{children:"It will give:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'Type checking:\nint | bool\n\nExecution: \n[1] FALSE\nattr(,"class")\n[1] "logical" "Union0"  "Generic"\n'})}),"\n",(0,s.jsx)(n.p,{children:"We can't use the result as we want. For instance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let a: int | bool <- 5;\n\na + 3\n"})}),"\n",(0,s.jsx)(n.p,{children:"Will give:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"Err(  \xd7 Type error: type int | bool doesn't match type int\n   \u256d\u2500[app.ty:3:14]\n 2 \u2502 \n 3 \u2502 let a: int | bool <- FALSE;\n   \xb7              \u25b2\n   \xb7              \u2570\u2500\u2500 Expected int | bool\n 4 \u2502 \n 5 \u2502 \n 6 \u2502 a + 3\n   \xb7     \u252c\n   \xb7     \u2570\u2500\u2500 Recieved int\n   \u2570\u2500\u2500\u2500\u2500\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because TypR can't find a the definition of the ",(0,s.jsx)(n.code,{children:"+"})," operator that apply to a type ",(0,s.jsx)(n.code,{children:"int | bool"})," and a type ",(0,s.jsx)(n.code,{children:"bool"}),". TypR will let us do that if we prove it we are working with an integer. You can do that using the ",(0,s.jsx)(n.code,{children:"match"})," block that will take into account each type case:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let a: int | bool <- 5;\n\nmatch a as x {\n\tint => x + 3,\n\tbool => 0\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'Type checking:\nint\n\nExecution: \n[1] 8\nattr(,"class")\n[1] "integer" "Union0"  "Generic"\n'})}),"\n",(0,s.jsx)(n.p,{children:"You can also work with union of tags:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-R",children:"type Option<T> = .Some(T) | .None;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And if my function can return a ",(0,s.jsx)(n.code,{children:"Na"})," and a ",(0,s.jsx)(n.code,{children:"NaN"})," instead of an int value you can define your own type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-R",children:"type Failable<T> = .Value(T) | .NaN | .Na | .None;\n"})}),"\n",(0,s.jsx)(n.p,{children:"This method is more flexible than an enum like Rust and more secure than an union from TypeScript."}),"\n",(0,s.jsx)(n.h2,{id:"interfaces-nightly",children:"Interfaces (nightly)"}),"\n",(0,s.jsx)(n.p,{children:"TypR interfaces works like Go's interfaces. It's a typed way of doing duck typing: If it walks like a duck and quacks like a duck, then it's a duck. So there is no implicit impl\xe9mentation of an existing interface."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Difference with R"}),"\nThere is no concept of union in R so nothing to compare."]}),"\n",(0,s.jsx)(n.p,{children:"You can define an interface in this fashion:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"type Addable = interface {\n\tadd: fn(a: Self, b: Self): Self,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can then define a function that take any addable type in this way:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let time3 <- fn(n: Addable) {\n\tadd(n, (add(n, n))\n};\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);