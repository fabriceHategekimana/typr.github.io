"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[830],{6009:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"typr-doc/typr-for-r-users","title":"TypR for R users","description":"Even though the syntax try to be as close as possible to R, there 1 fundamental difference: Semicolons.","source":"@site/docs/typr-doc/typr-for-r-users.md","sourceDirName":"typr-doc","slug":"/typr-doc/typr-for-r-users","permalink":"/typr.github.io/build/docs/typr-doc/typr-for-r-users","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/typr-doc/typr-for-r-users.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Documentation","permalink":"/typr.github.io/build/docs/typr-doc/"},"next":{"title":"typr-type-system","permalink":"/typr.github.io/build/docs/typr-doc/typr-type-system"}}');var a=t(4848),s=t(8453);const o={sidebar_position:1},r="TypR for R users",c={},l=[{value:"Semicolons",id:"semicolons",level:2},{value:"Philosophy: flexibillity and type safety",id:"philosophy-flexibillity-and-type-safety",level:2},{value:"What is TypR",id:"what-is-typr",level:3},{value:"What TypR is not",id:"what-typr-is-not",level:3},{value:"First code",id:"first-code",level:2},{value:"Static typing",id:"static-typing",level:2},{value:"Types and other construct",id:"types-and-other-construct",level:2},{value:"Typing with &quot;let&quot;",id:"typing-with-let",level:3},{value:"Typing with &quot;@&quot;",id:"typing-with-",level:3},{value:"Typing custom functions",id:"typing-custom-functions",level:2},{value:"Typing existing S3 classes",id:"typing-existing-s3-classes",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"typr-for-r-users",children:"TypR for R users"})}),"\n",(0,a.jsx)(n.p,{children:"Even though the syntax try to be as close as possible to R, there 1 fundamental difference: Semicolons."}),"\n",(0,a.jsx)(n.h2,{id:"semicolons",children:"Semicolons"}),"\n",(0,a.jsx)(n.p,{children:'Now, each declaration, assignation, expression (except the last one) must finish with a semicolon.\nTypR allow more powerful constructs that needs a marker such as ";" to delimit them.\nIf there is an error, that mean you need to put a semicolon at the end of your expression.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-R",children:"library(dplyr); # works\nlibrary(dplyr) # doesn't work\n"})}),"\n",(0,a.jsx)(n.h2,{id:"philosophy-flexibillity-and-type-safety",children:"Philosophy: flexibillity and type safety"}),"\n",(0,a.jsx)(n.h3,{id:"what-is-typr",children:"What is TypR"}),"\n",(0,a.jsxs)(n.p,{children:['"TypR" is a word game with Typescript (a superset of JavaScript) and the common way of naming things in the R community. The initial goal is to create a better experience with building packages for R (I want them to be easily compatible with the CRAN\'s requirements and to be easy to ship). Indeed, TypR ',(0,a.jsx)(n.em,{children:"is not only a type checker"})," but bring greater tools to build packages for data science in general and want to be an easy way to convert research paper into code. TypR add gradual typing, great static types and a flexible syntax with some cool tricks (metaprogramming) that make it great to work with."]}),"\n",(0,a.jsx)(n.h3,{id:"what-typr-is-not",children:"What TypR is not"}),"\n",(0,a.jsx)(n.p,{children:"Although TypR looks like the next cool kid in the town with a syntax greatly inspired by R, Rust and has many interesting feature from Go, Nim and Roc, it doesn't try to replace them at all but tend to help package builder and manager to reach their goals. This will help many developper, to bring value into the R community and the datascience community in a broader scope."}),"\n",(0,a.jsx)(n.p,{children:"Even though it looks strongly like it and follow its principles, TypR is not fundamentally OOP. As well as R who is more of a functional programming language, TypR follow this path for good reasons. Firstly because the realm of datascience is flooded with programming languages who are more on the Object oriented programming side. Don't get me wrong, it has its own strength but its own weaknesses too. Especially because it has his own limits in element representation (uniquely done with OOP) and strange design patterns that could be made easier with functional programming. Functional programming offer a bit more high level representation with less headache and the power of creating easy pipelines and parallelizable code."}),"\n",(0,a.jsx)(n.h2,{id:"first-code",children:"First code"}),"\n",(0,a.jsxs)(n.p,{children:["Let's build our first exemple! You can create a file named ",(0,a.jsx)(n.code,{children:"app.ty"})," (or the name you want). TypR has a generalized syntax for building type. To create a numeric, you just have to write:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"a <- 5.0;\n\na\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can now run it with this command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"typr app.ty\n"})}),"\n",(0,a.jsx)(n.p,{children:"You will get this result:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Type checking: \nnum\n\nExecution: \n[1] 5\n"})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, typR display two things. The first is the result of the type checking. TypR know that you defined a numeric so the expression ",(0,a.jsx)(n.code,{children:"a"})," evaluate to the type ",(0,a.jsx)(n.code,{children:"num"})," (=numeric)."]}),"\n",(0,a.jsxs)(n.p,{children:["The second thing displayed is the evaluation of the value of the variable ",(0,a.jsx)(n.code,{children:"a"}),". Since we created it with the value ",(0,a.jsx)(n.code,{children:"5.0"})," it take it as it is."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"typr"})," binary created three files to do this task. They exist in the current directory and are respectively named ",(0,a.jsx)(n.code,{children:"std.R"}),", ",(0,a.jsx)(n.code,{children:"app.R"})," and ",(0,a.jsx)(n.code,{children:"std.ty"}),". ",(0,a.jsx)(n.code,{children:"std.ty"})," is the file containing a set of predefined variables and types that will be present in each project. ",(0,a.jsx)(n.code,{children:"std.R"})," contains some utilitarian function to type and interpret basic operator (see ",(0,a.jsx)(n.code,{children:"operator overloading"}),"). There are some default R functions and predefined TypR functions. The ",(0,a.jsx)(n.code,{children:"app.R"})," is the main file with the type annotation removed:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-R",children:"# [other prebuild stuffs to work with typR]\n# ...\n\na <- 5\na\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You don't need to pay attention to the first lines of the document but to the last two lines. As you see, it's almost the same thing as the ",(0,a.jsx)(n.code,{children:"app.ty"}),' document with the exception of some element removed (the "let", and the type annotation). Of course TypR is not just R with types but it brings other great constructs from metaprogramming that will also bring a simpler syntax in TypR. It will build some code for you on the R\'s side. You can play with it and see it for yourself.']}),"\n",(0,a.jsx)(n.h2,{id:"static-typing",children:"Static typing"}),"\n",(0,a.jsxs)(n.p,{children:["In TypR, each variable keep their types once set. If we keep the previous example and try to set the logical value ",(0,a.jsx)(n.code,{children:"TRUE"}),", TypR won't permit it."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"a <- 5.0;\na <- TRUE; \n\na\n"})}),"\n",(0,a.jsx)(n.p,{children:"It will lead to this error:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Err(  \xd7 Type error: type num doesn't match type bool\n   \u256d\u2500[app.ty:1:1]\n 1 \u2502 a <- 5.0;\n   \xb7 \u25b2\n   \xb7 \u2570\u2500\u2500 Expected num\n 2 \u2502 a <- TRUE;\n   \xb7      \u252c\n   \xb7      \u2570\u2500\u2500 Recieved bool\n 3 \u2502 \n   \u2570\u2500\u2500\u2500\u2500\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Indeed, for TypR, ",(0,a.jsx)(n.code,{children:"a"})," has already the type ",(0,a.jsx)(n.code,{children:"int"})," (=integer) so it can't take a new type ",(0,a.jsx)(n.code,{children:"bool"})," (=logical). This feature is there so the kind of value a variable recieve stay consistent. For instance, it can help to be sure the modifications made to a variable holding a dataframe still return a dataframe if we want to reasign them to the same variable."]}),"\n",(0,a.jsxs)(n.p,{children:["If you still want to change the type of a variable, you can use the ",(0,a.jsx)(n.code,{children:"let"})," keyword so TypR know you are declaring a new type for the variable."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"a <- 5.0;\nlet a <- TRUE; \n\na\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will lead to this result:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Type checking:\nbool\n\nExecution: \n[1] TRUE\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Another advantage of the ",(0,a.jsx)(n.code,{children:"let"})," keyword lies in the fact you have a visual indication of where a variable is declared in your code. It can be a good habits to put ",(0,a.jsx)(n.code,{children:"let"})," at each variable declaration and omitting it when your just assigning a new value."]}),"\n",(0,a.jsx)(n.h2,{id:"types-and-other-construct",children:"Types and other construct"}),"\n",(0,a.jsxs)(n.p,{children:["Exept from primitive types and lists. Other function call like ",(0,a.jsx)(n.code,{children:"c()"})," will lead to the ",(0,a.jsx)(n.code,{children:"Empty"})," type even if it doesn't match the value."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"c(1, 2, 3, 4)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Will give:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Type checking:\nEmpty\n\nExecution: \n[1] 1 2 3 4\n"})}),"\n",(0,a.jsx)(n.p,{children:"But there are 2 ways to add types to things."}),"\n",(0,a.jsx)(n.h3,{id:"typing-with-let",children:'Typing with "let"'}),"\n",(0,a.jsx)(n.p,{children:'You can assign arbitrary types to the result of an R function call by just "Forcing" it to a hosting variable.'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let a: int <- c(1, 2, 3, 4);\n\na\n"})}),"\n",(0,a.jsx)(n.p,{children:"Will give:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Type checking:\nint\n\nExecution: \n[1] 1 2 3 4\n"})}),"\n",(0,a.jsx)(n.p,{children:"todo: warning about arbitrary type"}),"\n",(0,a.jsx)(n.h3,{id:"typing-with-",children:'Typing with "@"'}),"\n",(0,a.jsxs)(n.p,{children:["You can define the signature of an existing function. For instance, you can define a signature for the ",(0,a.jsx)(n.code,{children:"c()"})," function with 4 elements:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"@c: (int, int, int, int) -> int;\nc(1, 2, 3, 4)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Will give:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Type checking:\nint\n\nExecution: \n[1] 1 2 3 4\n"})}),"\n",(0,a.jsx)(n.p,{children:"todo: warning limitation of function with arbitrary number of parameters;"}),"\n",(0,a.jsx)(n.h2,{id:"typing-custom-functions",children:"Typing custom functions"}),"\n",(0,a.jsxs)(n.p,{children:["If you want to type a custom function, you have to write it with the ",(0,a.jsx)(n.code,{children:"fn"})," keyword. TypR will require you to set a type for each parameter and for the return value."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"let addition <- fn(a: int, b: int): int {\n\ta + b\n};\n\naddition(3, 4)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Will give:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Type checking:\nint\n\nExecution: \n[1] 7\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One thing important to know, TypR use by default ",(0,a.jsx)(n.code,{children:"S3"}),' for any typed values. That mean, TypR will create a "typing" function that will give a specific class to any value (even function) and will create generic functions if they don\'t exists.']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-R",children:"Function1 <- function(x) x |> struct(c('Function1', 'Generic', 'Function0'))\n\naddition <- function(x, ...) {\n\tUseMethod('addition')\n}\n\n\naddition.integer <- (function(a, b) {\n add(a, b) \n}) |> Function1()\n\naddition(3L, 4L)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"typing-existing-s3-classes",children:"Typing existing S3 classes"}),"\n",(0,a.jsx)(n.p,{children:"If you know an existing S3 class that you want to set up."}),"\n",(0,a.jsxs)(n.p,{children:["For instance you know that a dataframe is of class ",(0,a.jsx)(n.code,{children:"data.frame"}),". You can set in by using a type definition. TypR will assign automatically the right kind of S3 classes."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'type Dataframe = Class("data.frame");\n\nlet df: Dataframe = read__csv("path/to/your/csv");\n\ndf\n'})}),"\n",(0,a.jsx)(n.p,{children:"This would give you:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"Type checking:\nDataframe\n\nExecution: \n...\n"})}),"\n",(0,a.jsx)(n.p,{children:"todo: classes with mutliple children"}),"\n",(0,a.jsxs)(n.p,{children:["There are also other cool Features you can use. You can check the ",(0,a.jsx)(n.a,{href:"/typr.github.io/build/docs/typr-doc/advanced-typr",children:"Advanced_TypR"})," page to do so."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);