"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[791],{2016:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"typr-doc/advanced-typr","title":"Advanced Typr","description":"Uniform function call","source":"@site/docs/typr-doc/advanced-typr.md","sourceDirName":"typr-doc","slug":"/typr-doc/advanced-typr","permalink":"/typr.github.io/build/docs/typr-doc/advanced-typr","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/typr-doc/advanced-typr.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"typr-type-system","permalink":"/typr.github.io/build/docs/typr-doc/typr-type-system"}}');var i=t(4848),a=t(8453);const s={sidebar_position:3},d="Advanced Typr",o={},c=[{value:"Uniform function call",id:"uniform-function-call",level:2},{value:"Operator overloading",id:"operator-overloading",level:2},{value:"Modules (nightly)",id:"modules-nightly",level:2},{value:"Struct embedding (nightly)",id:"struct-embedding-nightly",level:2},{value:"Generics + Index Generics",id:"generics--index-generics",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"advanced-typr",children:"Advanced Typr"})}),"\n",(0,i.jsx)(n.h2,{id:"uniform-function-call",children:"Uniform function call"}),"\n",(0,i.jsx)(n.p,{children:"UFC (uniform function call) is one of my favourite features in programming language. I love the simplicity of methods, but I am not a fan of classes anymore since they are less expressive than algebraic data types in general. But working with my functions using types and module and pipes isn't totaly complet without methods call. So UFC bring the best of both worlds to me. I have also added some other forms with the original."}),"\n",(0,i.jsx)(n.p,{children:"For instance, we can see the definition of the add function for interger types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"let incr <- fn(a: int): int {\n\ta + 1\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now we can call it in different ways that gives the same results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"incr(2)\n(2).incr()\n2 |> incr()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There are the special elements ",(0,i.jsx)(n.code,{children:".."})," or ",(0,i.jsx)(n.code,{children:"|>>"})," that make a function operate on an array level."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"[1, 2, 3]..incr()\n[1, 2, 3] |>> incr()\n"})}),"\n",(0,i.jsx)(n.p,{children:"This code will apply an addition with 3 for each element."}),"\n",(0,i.jsx)(n.h2,{id:"operator-overloading",children:"Operator overloading"}),"\n",(0,i.jsx)(n.p,{children:"Operator overloading is one of my favourite element to build operations on types. It's a shortcut and a syntax sugar that let the user define operations for their custom types."}),"\n",(0,i.jsx)(n.p,{children:"Imagine we create a type named point:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"type Point = {x: int, y: int};\n\nlet p1 <- :{x: 2, y: 1};\n\np1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You can define a function ",(0,i.jsx)(n.code,{children:"add"})," to add two points. Let's assume you just add each coordinates."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"let add <- fn(p: Point, q: Point): Point {\n\t:{x: ((p.x) + (q.x)), y: ((p.y) + (q.y))}\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can obviously use the function in differtent ways:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"add(p1, p1)\np1.add(p1)\np1 |> add(p1)\n"})}),"\n",(0,i.jsx)(n.p,{children:"But you can also add point in this fashion:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"p1 + p1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Why is it possible ? Because ",(0,i.jsx)(n.code,{children:"add"})," is a reserved symbol related to the binary operation ",(0,i.jsx)(n.code,{children:"+"}),". So each time TypR see a ",(0,i.jsx)(n.code,{children:"a+b"}),", it transform it to ",(0,i.jsx)(n.code,{children:"add(a, b)"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"There are a group of reserved operators that change to their function's form."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"operator"}),(0,i.jsx)(n.th,{children:"function name"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"+"}),(0,i.jsx)(n.td,{children:"add"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"++"}),(0,i.jsx)(n.td,{children:"add2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"-"}),(0,i.jsx)(n.td,{children:"minus"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"--"}),(0,i.jsx)(n.td,{children:"minus2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"*"}),(0,i.jsx)(n.td,{children:"mul"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"**"}),(0,i.jsx)(n.td,{children:"mul2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"/"}),(0,i.jsx)(n.td,{children:"div"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"//"}),(0,i.jsx)(n.td,{children:"div2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"@"}),(0,i.jsx)(n.td,{children:"at"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"@@"}),(0,i.jsx)(n.td,{children:"at2"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"You don't have to worry about the usage of if an operator is related to an other type. Each type can use each symbol once."}),"\n",(0,i.jsx)(n.h2,{id:"modules-nightly",children:"Modules (nightly)"}),"\n",(0,i.jsx)(n.p,{children:"Modules are a useful tool that allow us to use the same name but in a different scope."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'module Foo {\n\tpub let my_var <- "hey";\n};\n\nmodule Bar {\n\tpub let my_var <- true;\n};\n\nlet my_var <- 7;\n\nFoo::my_var\nBar::my_var\nmy_var\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this exemple, my_var is defined in 3 different place with a different value and even a different type each time. But if ",(0,i.jsx)(n.code,{children:"my_var"})," is defined in a module like in the ",(0,i.jsx)(n.code,{children:"Foo"})," or ",(0,i.jsx)(n.code,{children:"Bar"})," module then we need to prefix the module name to have access to this variable."]}),"\n",(0,i.jsx)(n.p,{children:"In OOP language we think in term of class and object, in language with a functional programming paradim orientation like TypR, we think in term of types. A type can be refered at any moment in the program and function that works with this type can also be declared at any moment in the program. This is why module exists: if needed, we can group types and their related functions in the same place and give it a name for reference."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'# not working yet\nmodule Cat {\n\tpub type Cat = {name: char, age: int};\n\t\n\tpub let cry <- fn(c: Cat): char {\n\t\t"meow"\n\t};\n};\n\nlet felix <- :{name: "Felix", age: 8};\nCat::cry(felix)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"struct-embedding-nightly",children:"Struct embedding (nightly)"}),"\n",(0,i.jsx)(n.p,{children:"Comming soon..."}),"\n",(0,i.jsx)(n.h2,{id:"generics--index-generics",children:"Generics + Index Generics"}),"\n",(0,i.jsx)(n.p,{children:"Generics is one of the hardest concept in this language, especially when we talk about Index Generics."}),"\n",(0,i.jsx)(n.p,{children:"In complex terms, generics is a way to create functions that allows functions to work with more types related to specific relationship with parameters (Parametric polymorphism)."}),"\n",(0,i.jsx)(n.p,{children:"Since it allow almost any type, it's better to use them for structural and general purpose. For instance, it's great to describe data structures that can works with many types (like array, graphs, tree, etc.). It's also greate to use it to shape function composition."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);